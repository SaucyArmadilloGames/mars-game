<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sTerminal</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Defined Variables
/*
    Text Writing HUD
    1/17/2016 by Gogurt
    A type writing object activated at different terminals.
    It is displayed by adding a new character from the current string.
    Currently, the text stream is defined depending on which room you are in,
    so multiple terminals in one room would require some additional reworking.
    Text streams are made up of as many pages of text you want, and the animation
    for writing all of the text can be skipped with E or Enter.
*/


active = false;
animatingText = false;
finishedPage = false;
finishedAll = false;

globalvar pageList;
pageList = ds_list_create();
currentPage = 0;

ScCheckRoomPages();

animatingLine = 0;
currentCharacter = 0;
characterDelay = 1; //Delays for one step

//Eventually determined by room-specific strings
fullText = ds_list_find_value(global.pageList, currentPage);


//Seperates string into multiple values with |
linesList = ds_list_create();
ds_list_add(linesList, ScString_Split(fullText, 0, "|"));
ds_list_add(linesList, ScString_Split(fullText, 1, "|"));
ds_list_add(linesList, ScString_Split(fullText, 2, "|"));
ds_list_add(linesList, ScString_Split(fullText, 3, "|"));
ds_list_add(linesList, ScString_Split(fullText, 4, "|"));
ds_list_add(linesList, ScString_Split(fullText, 5, "|"));
ds_list_add(linesList, ScString_Split(fullText, 6, "|"));

currentText = string_copy(ds_list_find_value(linesList, animatingLine), 0, 1);

//Visual
depth = 10;
backdropYPos = 15;
animatingBackdrop = false;
backdropOpacity = 0;

textOpacity = 0.8;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Writer Update Manager
if(active)
{
    //Fades in terminal backdrop
    if(animatingBackdrop)
    {
        backdropYPos--;
        backdropOpacity += 0.1;
        if(backdropYPos &lt;= 5)
        {
            animatingBackdrop = false;
            animatingText = true;
        }
    }
    //Animates the string
    if(animatingText &amp;&amp; backdropYPos &lt;= 5)
    {
        textOpacity = 0.8;
        //Character assessment
        if(string_length(currentText) &gt;= string_length(ds_list_find_value(linesList, animatingLine)))
        {
            animatingLine++;
            currentCharacter = 1;
            currentText = string_copy(ds_list_find_value(linesList, animatingLine), 0, currentCharacter);
        }
        else
        {
            currentText = string_copy(ds_list_find_value(linesList, animatingLine), 0, currentCharacter);
            if(characterDelay == 0)
            {
                currentCharacter++;
                characterDelay = 1;
                //Audio
                if(string_length(currentText) % 3 == 0)
                {
                    audio_play_sound(aTerminalBlip0, 1, false)
                    textOpacity = 0.7;
                }
            }
            else
            {
                characterDelay--;
            }
        }
        if(animatingLine == 6)
        {            
            finishedPage = true;
            animatingText = false;
            textOpacity = 0.8;
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="oPlayer">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Player Collision Detection
//When you first activate a terminal
if(keyboard_check_pressed(ord('E')) &amp;&amp; active == false)
{
    currentPage = 0;
    active = true;
    animatingBackdrop = true;
    finishedPage = false;
    finishedAll = false;
    audio_play_sound(aTerminalStart,1,false)
    oPlayer.pausePlayer = true;
}
//When all text has been presented, variable reset
else if(keyboard_check_pressed(ord('E')) &amp;&amp; finishedAll == true)
{
    currentPage = 0;
    currentCharacter = 1;
    currentText = "";
    active = false;
    backdropYPos = 15;
    backdropOpacity = 0;
    animatingLine = 0;
    oPlayer.pausePlayer = false;
}
else if(keyboard_check_pressed(ord('E')) &amp;&amp; finishedPage == true &amp;&amp; finishedAll = false)
{
    currentPage++;
    fullText = ds_list_find_value(global.pageList, 1);
    linesList = ds_list_create();
    ds_list_add(linesList, ScString_Split(fullText, 0, "|"));
    ds_list_add(linesList, ScString_Split(fullText, 1, "|"));
    ds_list_add(linesList, ScString_Split(fullText, 2, "|"));
    ds_list_add(linesList, ScString_Split(fullText, 3, "|"));
    ds_list_add(linesList, ScString_Split(fullText, 4, "|"));
    ds_list_add(linesList, ScString_Split(fullText, 5, "|"));
    ds_list_add(linesList, ScString_Split(fullText, 6, "|"));

    animatingLine = 0;
    currentText = string_copy(ds_list_find_value(linesList, animatingLine), 0, 1);
    finishedPage = false;
    animatingText = true;
    currentCharacter = 1;
    finishedText = false;
}
//When text is still animating and you want to reveal the whole page
else if(keyboard_check_pressed(ord('E')) &amp;&amp; animatingText &amp;&amp; animatingBackdrop == false)
{
    currentText = fullText;
    animatingText = false;
    finishedPage = true;
    animatingLine = 0;
    currentCharacter = 1;
    if(currentPage == ds_list_size(global.pageList))
    {
        finishedAll = true;
    }
    else
    {
        currentPage++;
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>524</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_color</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>13</kind>
            <string>16777215</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(active)
{
    draw_sprite_ext(sTerminalBackdrop, 1, 5, backdropYPos, 1, 1, 0, c_white, backdropOpacity);
    if(animatingText == true)
    {
        switch(animatingLine)
        {
            case 0:
                draw_text_colour(40, 40, currentText, c_white, c_white, c_white, c_white, textOpacity);
            break;
            
            case 1:
                draw_text_colour(40, 40, ds_list_find_value(linesList, 0), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 70, currentText, c_white, c_white, c_white, c_white, textOpacity);
            break;
            
            case 2:
                draw_text_colour(40, 40, ds_list_find_value(linesList, 0), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 70, ds_list_find_value(linesList, 1), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 100, currentText, c_white, c_white, c_white, c_white, textOpacity);
            break;
            
            case 3:
                draw_text_colour(40, 40, ds_list_find_value(linesList, 0), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 70, ds_list_find_value(linesList, 1), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 100, ds_list_find_value(linesList, 2), c_white, c_white, c_white, c_white, textOpacity);      
                draw_text_colour(40, 130, currentText, c_white, c_white, c_white, c_white, textOpacity);
           
            break;
            
            case 4:
                draw_text_colour(40, 40, ds_list_find_value(linesList, 0), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 70, ds_list_find_value(linesList, 1), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 100, ds_list_find_value(linesList, 2), c_white, c_white, c_white, c_white, textOpacity);      
                draw_text_colour(40, 130, ds_list_find_value(linesList, 3), c_white, c_white, c_white, c_white, textOpacity);      
                draw_text_colour(40, 160, currentText, c_white, c_white, c_white, c_white, textOpacity);
            break;
            
            case 5:
                draw_text_colour(40, 40, ds_list_find_value(linesList, 0), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 70, ds_list_find_value(linesList, 1), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 100, ds_list_find_value(linesList, 2), c_white, c_white, c_white, c_white, textOpacity);      
                draw_text_colour(40, 130, ds_list_find_value(linesList, 3), c_white, c_white, c_white, c_white, textOpacity);      
                draw_text_colour(40, 160, ds_list_find_value(linesList, 4), c_white, c_white, c_white, c_white, textOpacity);       
                draw_text_colour(40, 190, currentText, c_white, c_white, c_white, c_white, textOpacity);
            break;
            
            case 6:
                draw_text_colour(40, 40, ds_list_find_value(linesList, 0), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 70, ds_list_find_value(linesList, 1), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 100, ds_list_find_value(linesList, 2), c_white, c_white, c_white, c_white, textOpacity);      
                draw_text_colour(40, 130, ds_list_find_value(linesList, 3), c_white, c_white, c_white, c_white, textOpacity);      
                draw_text_colour(40, 160, ds_list_find_value(linesList, 4), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 190, ds_list_find_value(linesList, 5), c_white, c_white, c_white, c_white, textOpacity);           
                draw_text_colour(40, 220, currentText, c_white, c_white, c_white, c_white, textOpacity);
            break;
            
            default:
                draw_text_colour(40, 40, ds_list_find_value(linesList, 0), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 70, ds_list_find_value(linesList, 1), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 100, ds_list_find_value(linesList, 2), c_white, c_white, c_white, c_white, textOpacity);      
                draw_text_colour(40, 130, ds_list_find_value(linesList, 3), c_white, c_white, c_white, c_white, textOpacity);      
                draw_text_colour(40, 160, ds_list_find_value(linesList, 4), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 190, ds_list_find_value(linesList, 5), c_white, c_white, c_white, c_white, textOpacity);
                draw_text_colour(40, 220, ds_list_find_value(linesList, 6), c_white, c_white, c_white, c_white, textOpacity);
            break;
        
        }

    }
    else if(finishedPage == true)
    {
        draw_text_colour(40, 40, ds_list_find_value(linesList, 0), c_white, c_white, c_white, c_white, textOpacity);
        draw_text_colour(40, 70, ds_list_find_value(linesList, 1), c_white, c_white, c_white, c_white, textOpacity);
        draw_text_colour(40, 100, ds_list_find_value(linesList, 2), c_white, c_white, c_white, c_white, textOpacity);      
        draw_text_colour(40, 130, ds_list_find_value(linesList, 3), c_white, c_white, c_white, c_white, textOpacity);      
        draw_text_colour(40, 160, ds_list_find_value(linesList, 4), c_white, c_white, c_white, c_white, textOpacity);
        draw_text_colour(40, 190, ds_list_find_value(linesList, 5), c_white, c_white, c_white, c_white, textOpacity);
        draw_text_colour(40, 220, ds_list_find_value(linesList, 6), c_white, c_white, c_white, c_white, textOpacity);
    }
}

draw_self();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
